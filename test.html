<!doctype html>
<html >
<head >
<script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js'>

</script>

<script >


// Module dependencies.
// Usually this is just Caterwaul and the standard extension. If you modify these, you should probably also run 'dependencies edit' to inform the script about where these files are downloaded
// from.

(function(a){return a(a)})(function(f,z,p){var ag=function(ao){return ao.split(/\s+/)},C=function(ao,ap){return ap&&ap.call(ao,ao)||ao},o=function(ao){throw new Error(ao)},c=z||(function(){for(var ao=[],aq="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_",ap=21,ar;ap>=0;--ap){ao.push(aq.charAt(Math.random()*64>>>0))}return ao.join("")})(),X=(function(ao){return function(ap){return[ap||"",(++ao).toString(36),c].join("_")}})(0),W=function(ao){return ao.substr(ao.length-22)===c},i=function(ap,ao){return function(){return ap.apply(ao,arguments)}},O=function(at,ap){for(var aq=0,ar=[],ao=ap.length;aq<ao;++aq){ar.push(at(ap[aq],aq))}return ar},w=function(ap,ao){return O(function(aq){return aq instanceof Array?w(ap,aq):ap(aq)})},ae=function(ar){for(var aq=0,ap=ag(ar),at={},ao=ap.length;aq<ao;++aq){at[ap[aq]]=true}return s(at)},ac=(function(ap){for(var ao in ap){if(ap.hasOwnProperty(ao)){return true}}})({toString:true})?function(at){for(var ar=1,ao=arguments.length,aq;ar<ao;++ar){if(aq=arguments[ar]){for(var ap in aq){if(g(aq,ap)){at[ap]=aq[ap]}}}}return at}:function(at){for(var ar=1,ao=arguments.length,aq;ar<ao;++ar){if(aq=arguments[ar]){for(var ap in aq){if(g(aq,ap)){at[ap]=aq[ap]}}if(aq.toString&&!/\[native code\]/.test(aq.toString.toString())){at.toString=aq.toString}}}return at},ab=X("hash"),s=function(aq){var ao=0;for(var ap in aq){l.call(aq,ap)&&(ao=ap.length>ao?ap.length:ao)}aq[ab]=ao;return aq},g=function(ap,ao){return ao!=null&&!(ao.length>ap[ab])&&l.call(ap,ao)},l=Object.prototype.hasOwnProperty,af=function(){var ao=function(){return ao.init.apply(ao,arguments)};return ao},ah=typeof caterwaul==="undefined"?p:caterwaul,an=C(af(),function(){this.deglobalize=function(){caterwaul=ah;return an};ac(this,{merge:ac,map:O,rmap:w,gensym:X,is_gensym:W})}),am=ae(". new ++ -- u++ u-- u+ u- typeof u~ u! ! * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || ? = += -= *= /= %= &= |= ^= <<= >>= >>>= : , return throw case var const break continue void else u; ;"),T=function(ar){for(var aq=0,ap=[false];aq<8;++aq){ap.push.apply(ap,ap)}for(var aq=0,ao=ar.length;aq<ao;++aq){ap[ar.charCodeAt(aq)]=true}return ap},ak=T(".0123456789"),V=T("0123456789"),y=T("0123456789abcdefABCDEFx"),L=T("eE"),j=T(" \n\r\t"),t=T("()[]{}?:"),r=T("([{?:"),x=T("+-*/%&|^!~=<>?:;.,"),J=T("\n\r"),k=T("gims"),P=T("'\"/"),n="/".charCodeAt(0),S="*".charCodeAt(0),m="\\".charCodeAt(0),aa="x".charCodeAt(0),N=".".charCodeAt(0),U="0".charCodeAt(0),aj=ae("++ --"),Y=T("$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"),K=O(ae,["function","( [ . [] ()","new delete","u++ u-- ++ -- typeof u~ u! u+ u-","* / %","+ -","<< >> >>>","< > <= >= instanceof in","== != === !==","&","^","|","&&","||","case","? = += -= *= /= %= &= |= ^= <<= >>= >>>=",":",",","return throw break continue void","var const","if else try catch finally for switch with while do",";"]),H=ae("= += -= *= /= %= &= ^= |= <<= >>= >>>= ~ ! new typeof u+ u- -- ++ u-- u++ ? if else function try catch finally for switch case with while do"),F=(function(aq){for(var at={},ar=0,ao=aq.length;ar<ao;++ar){for(var ap in aq[ar]){g(aq[ar],ap)&&(at[ap]=ar)}}return s(at)})(K),v=(function(aq){for(var at=[],au=0,ao=aq.length,ar=null;ar=aq[au],at[au]=true,au<ao;++au){for(var ap in ar){if(g(ar,ap)&&(at[au]=at[au]&&!g(H,ap))){break}}}return at})(K),B=ae("[] . () * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || = += -= *= /= %= &= |= ^= <<= >>= >>>= , : ;"),Z=s({"function":2,"if":1,"do":1,"catch":1,"try":1,"for":1,"while":1,"with":1,"switch":1}),R=s({"if":"else","do":"while","catch":"finally","try":"catch"}),D=ae("[] ()"),ai=ae("return throw break continue else"),E=ae("u+ u- u! u~ u++ u-- new typeof finally case var const void delete"),h=ae("; {"),ad=ae("i;"),I=ae("++ --"),q=s({"(":")","[":"]","{":"}","?":":"}),G=ae("[ ("),Q=ae("?"),e=ae("function if for while catch void delete new typeof in instanceof"),A=ae("function"),u=an.syntax_common={_replace:function(ao){return(ao.l=this.l)&&(this.l.r=ao),(ao.r=this.r)&&(this.r.l=ao),this},_append_to:function(ao){return ao&&ao._append(this),this},_reparent:function(ao){return this.p&&this.p[0]===this&&(this.p[0]=ao),this},_fold_l:function(ao){return this._append(this.l&&this.l._unlink(this)||a)},_append:function(ao){return(this[this.length++]=ao)&&(ao.p=this),this},_fold_r:function(ao){return this._append(this.r&&this.r._unlink(this)||a)},_sibling:function(ao){return ao.p=this.p,(this.r=ao).l=this},_fold_lr:function(){return this._fold_l()._fold_r()},_fold_rr:function(){return this._fold_r()._fold_r()},_wrap:function(ao){return ao.p=this._replace(ao).p,this._reparent(ao),delete this.l,delete this.r,this._append_to(ao)},_unlink:function(ao){return this.l&&(this.l.r=this.r),this.r&&(this.r.l=this.l),delete this.l,delete this.r,this._reparent(ao)},pop:function(){return --this.length,this},push:function(ao){return this[this.length++]=ao||a,this},id:function(){var ao=X("id");return(this.id=function(){return ao})()},is_caterwaul_syntax:true,each:function(aq){for(var ap=0,ao=this.length;ap<ao;++ap){aq(this[ap],ap)}return this},map:function(aq){for(var ar=new this.constructor(this),ap=0,ao=this.length;ap<ao;++ap){ar.push(aq(this[ap],ap)||this[ap])}return ar},reach:function(ao){ao(this);this.each(function(ap){ap.reach(ao)});return this},rmap:function(ap){var ao=ap(this);return !ao||ao===this?this.map(function(aq){return aq.rmap(ap)}):ao===true?this:ao.rmap===p?new this.constructor(ao):ao},peach:function(ao){this.each(function(ap){ap.peach(ao)});ao(this);return this},pmap:function(ap){var ao=this.map(function(aq){return aq.pmap(ap)});return ap(ao)},clone:function(){return this.rmap(function(){return false})},collect:function(ap){var ao=[];this.reach(function(aq){ap(aq)&&ao.push(aq)});return ao},replace:function(ao){var ap;return l.call(ao,this.data)&&(ap=ao[this.data])?ap.constructor===String?C(this.map(function(aq){return aq.replace(ao)}),function(){this.data=ap}):ap:this.map(function(aq){return aq.replace(ao)})},repopulated_with:function(ao){return new this.constructor(this.data,ao)},with_data:function(ao){return new this.constructor(ao,Array.prototype.slice.call(this))},change:function(ap,ao){return C(new this.constructor(this.data,Array.prototype.slice.call(this)),function(aq){aq[ap]=ao})},compose_single:function(ao,ap){return this.change(ao,ap(this[ao]))},slice:function(ap,ao){return new this.constructor(this.data,Array.prototype.slice.call(this,ap,ao))},traverse:function(ao){ao({entering:this});ao({exiting:this.each(function(ap){ap.traverse(ao)})});return this},flatten:function(ao){ao=ao||this.data;return ao!==this.data?this.as(ao):!(g(B,ao)&&this.length)?this:g(H,ao)?C(new this.constructor(ao),i(function(aq){for(var ap=this;ap&&ap.data===ao;ap=ap[1]){aq.push(ap[0])}aq.push(ap)},this)):C(new this.constructor(ao),i(function(ar){for(var ap=this,aq=[];ap.data===ao;ap=ap[0]){ap[1]&&aq.push(ap[1])}aq.push(ap);for(ap=aq.length-1;ap>=0;--ap){ar.push(aq[ap])}},this))},unflatten:function(){var ap=this,ao=g(H,this.data);return this.length<=2?this:C(new this.constructor(this.data),function(at){if(ao){for(var ar=0,aq=ap.length-1;ar<aq;++ar){at=at.push(ap[ar]).push(ar<aq-2?new ap.constructor(ap.data):ap[ar])[1]}}else{for(var ar=ap.length-1;ar>=1;--ar){at=at.push(ar>1?new ap.constructor(ap.data):ap[0]).push(ap[ar])[0]}}})},as:function(ao){return this.data===ao?this:new this.constructor(ao).push(this)},bindings:function(ap){var ao=ap||{};this.reach(function(aq){if(aq.binds_a_value){ao[aq.data]=aq.value}});return ao},contains:function(ar){var ao=ar(this);if(ao){return ao}for(var aq=0,ap=this.length;aq<ap;++aq){if(ao=this[aq].contains(ar)){return ao}}},match:function(aq,ar){aq=aq.constructor===String?an.parse(aq):aq;ar||(ar={_:aq});if(this.is_wildcard()){return ar[this.data]=aq,ar}else{if(this.length===aq.length&&this.data===aq.data){for(var ap=0,ao=this.length;ap<ao;++ap){if(!this[ap].match(aq[ap],ar)){return null}}return ar}}},toString:function(){var ao=[""];this.serialize(ao);return ao.join("")},structure:function(){if(this.length){return"("+['"'+this.data+'"'].concat(O(function(ao){return ao.structure()},this)).join(" ")+")"}else{return this.data}}};an.syntax_subclass=function(aq){var ap=Array.prototype.slice.call(arguments,1),ao=function(){return aq.apply(this,arguments)};ac.apply(this,[ao.prototype,u].concat(ap));ao.prototype.constructor=ao;return ao};var b=an.parse_hex=function(ar){for(var ao=0,aq=0,ap=ar.length,at;aq<ap;++aq){ao*=16,ao+=(at=ar.charCodeAt(aq))<=58?at-48:(at&95)-55}return ao},al=an.parse_octal=function(ar){for(var ao=0,aq=0,ap=ar.length;aq<ap;++aq){ao*=8,ao+=ar.charCodeAt(aq)-48}return ao},d=an.unescape_string=function(at){for(var ar=0,au,ap=at.length,ao=[],aq=false;ar<ap;++ar){if(aq){aq=false,ao.push((au=at.charAt(ar))==="\\"?"\\":au==="n"?"\n":au==="r"?"\r":au==="b"?"\b":au==="f"?"\f":au==="0"?"\u0000":au==="t"?"\t":au==="v"?"\v":au==='"'||au==="'"?au:au==="x"?String.fromCharCode(b(at.substring(ar,++ar+1))):au==="u"?String.fromCharCode(b(at.substring(ar,(ar+=3)+1))):String.fromCharCode(al(at.substring(ar,(ar+=2)+1))))}else{if((au=at.charAt(ar))==="\\"){aq=true}else{ao.push(au)}}}return ao.join("")};an.javascript_tree_type_methods={is_string:function(){return/['"]/.test(this.data.charAt(0))},as_escaped_string:function(){return this.data.substr(1,this.data.length-2)},is_number:function(){return/^-?(0x|\d|\.\d+)/.test(this.data)},as_number:function(){return Number(this.data)},is_boolean:function(){return this.data==="true"||this.data==="false"},as_boolean:function(){return this.data==="true"},is_regexp:function(){return/^\/./.test(this.data)},as_escaped_regexp:function(){return this.data.substring(1,this.data.lastIndexOf("/"))},is_array:function(){return this.data==="["},as_unescaped_string:function(){return d(this.as_escaped_string())},is_wildcard:function(){return this.data.charCodeAt(0)===95},is_identifier:function(){return this.length===0&&/^[A-Za-z_$]\w*$/.test(this.data)&&!this.is_boolean()&&!this.is_null_or_undefined()&&!g(am,this.data)},has_grouped_block:function(){return g(Z,this.data)},is_block:function(){return g(h,this.data)},is_blockless_keyword:function(){return g(ai,this.data)},is_null_or_undefined:function(){return this.data==="null"||this.data==="undefined"},is_constant:function(){return this.is_number()||this.is_string()||this.is_boolean()||this.is_regexp()||this.is_null_or_undefined()},left_is_lvalue:function(){return/=$/.test(this.data)||/\+\+$/.test(this.data)||/--$/.test(this.data)},is_empty:function(){return !this.length},has_parameter_list:function(){return this.data==="function"||this.data==="catch"},has_lvalue_list:function(){return this.data==="var"||this.data==="const"},is_dereference:function(){return this.data==="."||this.data==="[]"},is_invocation:function(){return this.data==="()"},is_contextualized_invocation:function(){return this.is_invocation()&&this[0].is_dereference()},is_invisible:function(){return g(ad,this.data)},is_binary_operator:function(){return g(B,this.data)},is_prefix_unary_operator:function(){return g(E,this.data)},is_postfix_unary_operator:function(){return g(I,this.data)},is_unary_operator:function(){return this.is_prefix_unary_operator()||this.is_postfix_unary_operator()},accepts:function(ao){return g(R,this.data)&&R[this.data]===(ao.data||ao)}};an.javascript_tree_serialization_methods={ends_with_block:function(){var ao=this[Z[this.data]];return this.data==="{"||g(Z,this.data)&&(this.data!=="function"||this.length===3)&&ao&&ao.ends_with_block()},serialize:function(ar){var ap=this.length,at=this.data,ao=";\n",aq=function(au){if(Y[ar[ar.length-1].charCodeAt(0)]===Y[au.charCodeAt(0)]){ar.push(" ",au)}else{ar.push(au)}};switch(ap){case 0:if(g(ai,at)){return aq(at.replace(/^u/,""))}else{if(g(q,at)){return aq(at),aq(q[at])}else{return aq(at)}}case 1:if(g(E,at)||g(ai,at)){return aq(at.replace(/^u/,"")),this[0].serialize(ar)}else{if(g(q,at)){return aq(at),this[0].serialize(ar),aq(q[at])}else{if(g(B,at)){return aq("/* unary "+at+" node */"),this[0].serialize(ar)}else{return this[0].serialize(ar),aq(at)}}}case 2:if(g(D,at)){return this[0].serialize(ar),aq(at.charAt(0)),this[1].serialize(ar),aq(at.charAt(1))}else{if(g(Z,at)){return aq(at),this[0].serialize(ar),this[1].serialize(ar)}else{if(g(ad,at)){return this[0].serialize(ar),this[1].serialize(ar)}else{if(at===";"){return this[0].serialize(ar),aq(ao),this[1].serialize(ar)}else{return this[0].serialize(ar),aq(at),this[1].serialize(ar)}}}}default:if(g(Q,at)){return this[0].serialize(ar),aq(at),this[1].serialize(ar),aq(":"),this[2].serialize(ar)}else{if(g(Z,at)){return this.accepts(this[2])&&!this[1].ends_with_block()?(aq(at),this[0].serialize(ar),this[1].serialize(ar),aq(ao),this[2].serialize(ar)):(aq(at),this[0].serialize(ar),this[1].serialize(ar),this[2].serialize(ar))}else{return this.unflatten().serialize(ar)}}}}};an.ref=an.syntax_subclass(function(ap,ao){if(ap instanceof this.constructor){this.value=ap.value,this.data=ap.data}else{this.value=ap,this.data=X(ao&&ao.constructor===String?ao:"ref")}},an.javascript_tree_type_methods,an.javascript_tree_serialization_methods,{binds_a_value:true,length:0},{replace:function(ao){var ap;return l.call(ao,this.data)&&(ap=ao[this.data])?ap.constructor===String?C(new this.constructor(this.value),function(){this.data=ap}):ap:this}});an.syntax=an.syntax_subclass(function(au){if(au instanceof this.constructor){this.data=au.data,this.length=0}else{this.data=au&&au.toString();this.length=0;for(var ar=1,ao=arguments.length,aq;aq=arguments[ar],ar<ao;++ar){for(var ap=0,aw=aq.length,at,av;aq instanceof Array?(at=aq[ap],ap<aw):(at=aq,!ap);++ap){this._append((av=at.constructor)===String||av===Number||av===Boolean?new this.constructor(at):at)}}}},an.javascript_tree_type_methods,an.javascript_tree_serialization_methods);var a=an.empty=new an.syntax("");an.parse=function(ao){if(ao.constructor===an.syntax){return ao}var aK=ao.toString(),au=0,aW=0,aH=true,aG=false,aY=false,aX=false,aL=0,aI="",aT=0,aQ=aK.length,aB=function(a0){return aK.charCodeAt(a0)},az=[],aP=null,ax=null,av=null,ap=O(function(){return[]},K),aw=[],aJ=[a],aR=function(a0){return aJ.push(a0),a0},aM=function(a0){return ax?ax._sibling(ax=a0):(ax=a0._append_to(av)),aR(a0)},aq=this.syntax,ay=[];if(aQ===0){return a}while((au=aT)<aQ){while(j[aW=aB(aT)]&&aT<aQ){au=++aT}aG=aX=aY=aI=false;if(t[aW]){aI=!!++aT;aH=r[aW]}else{if(aW===n&&aB(aT+1)===S&&(aT+=2)){while(++aT<aQ&&aB(aT)!==n||aB(aT-1)!==S){}aI=!++aT}else{if(aW===n&&aB(aT+1)===n){while(++aT<aQ&&!J[aB(aT)]){}aI=false}else{if(P[aW]&&(aL=aW)&&aH&&!(aH=!(aI=aK.charAt(aT)))){while(++aT<aQ&&(aW=aB(aT))!==aL||aG){aG=!aG&&aW===m}while(++aT<aQ&&k[aB(aT)]){}aI=true}else{if(aW===U&&y[aB(aT+1)]){while(++aT<aQ&&y[aB(aT)]){}aH=!(aI=true)}else{if(ak[aW]&&(aW!==N||V[aB(aT+1)])){while(++aT<aQ&&(V[aW=aB(aT)]||(aY^(aY|=aW===N))||(aX^(aX|=L[aW]&&++aT)))){}while(aT<aQ&&V[aB(aT)]){++aT}aH=!(aI=true)}else{if(x[aW]&&(aI=aH?"u":"",aH=true)){while(aT<aQ&&x[aB(aT)]&&g(am,aI+aK.charAt(aT))){aI+=aK.charAt(aT++)}aH=!g(aj,aI)}else{while(++aT<aQ&&(Y[aW=aB(aT)]||aW>127)){}aH=g(am,aI=aK.substring(au,aT))}}}}}}}if(aT===au){throw new Error('Caterwaul lex error at "'+aK.substr(au,40)+'" with leading context "'+aK.substr(au-40,40)+'" (probably a Caterwaul bug)')}if(aI===false){continue}aI=aI===true?aK.substring(au,aT):aI==="u;"?";":aI;aI===aP?(az.pop(),aP=az[az.length-1],ax=ax?ax.p:av,av=null):(g(q,aI)?(az.push(aP=q[aI]),av=aM(aR(new aq(aI))),ax=null):aM(aR(new aq(aI))),g(F,aI)&&ap[F[aI]].push(ax||av));aH|=aI===")"&&ax.l&&g(Z,ax.l.data)}for(var aT=0,aQ=ap.length,aF,aZ;aZ=ap[aT],aF=v[aT],aT<aQ;++aT){for(var aS=aF?0:aZ.length-1,aE=aZ.length,aU=aF?1:-1,aC,aV,aD;aF?aS<aE:aS>=0;aS+=aU){if(g(B,aV=(aC=aZ[aS]).data)){aC._fold_lr()}else{if(g(G,aV)&&aC.l&&!((aD=aC.l.l)&&g(Z,aD.data))&&(aC.l.data==="."||(aC.l.data==="function"&&aC.l.length===2)||!(g(am,aC.l.data)||g(e,aC.l.data)))){aw.push(aC.l._wrap(aR(new aq(aV+q[aV]))).p._fold_r())}else{if(g(I,aV)){aC._fold_l()}else{if(g(E,aV)){aC._fold_r()}else{if(g(Q,aV)){aC._fold_lr(),ay.push(aC)}else{if(g(Z,aV)&&aC.r&&aC.r.data!==":"){for(var aN=0,aA=Z[aV];aN<aA&&aC.r&&!g(h,aC.r.data);++aN){aC._fold_r()}aC.r&&(aC.r.data===";"?aC.push(a):aC._fold_r());if(g(R,aV)&&R[aV]===(aC.r&&aC.r.r&&aC.r.r.data)){aC._fold_r().pop()._fold_r()}else{if(g(R,aV)&&R[aV]===(aC.r&&aC.r.data)){aC._fold_r()}}}else{if(g(ai,aV)){aC.r&&aC.r.data!==";"&&aC._fold_r()}}}}}}}}}for(var aT=aJ.length-1,aZ;aT>=0;--aT){(aZ=aJ[aT]).r&&aZ._wrap(aR(new aq("i;"))).p._fold_r()}for(var aT=0,aQ=aw.length,aZ,ar;aT<aQ;++aT){(ar=(aZ=aw[aT])[1]=aZ[1][0]||a)&&(ar.p=aZ)}for(var aT=0,aQ=ay.length,aZ,aO,at;aT<aQ;++aT){aO=(aZ=ay[aT]).length,at=aZ[0],aZ[0]=aZ[aO-2],aZ[1]=at,aZ[2]=aZ[aO-1],aZ.length=3}while(ax.p){ax=ax.p}for(var aT=aJ.length-1,aZ;aT>=0;--aT){delete (aZ=aJ[aT]).p,delete aZ.l,delete aZ.r}return ax};(function(){var ao=an.parse("var _bindings; return(_expression)"),aq=an.parse("_variable = _base._variable"),ap=an.parse("undefined = void(0)");an.compile=function(aD,ax,aC){aC=ac({gensym_renaming:true},aC);var au=ac({},this._environment||{},ax||{},aD.bindings()),az=[ap],aB=X("base");for(var aw in au){if(l.call(au,aw)&&aw!=="this"){az.push(aq.replace({_variable:aw,_base:aB}))}}var aA=new this.syntax(",",az).unflatten(),ar=ao.replace({_bindings:aA,_expression:aD});if(aC.gensym_renaming){var av=this.gensym_rename_table(ar);for(var aw in au){l.call(au,aw)&&(au[av[aw]||aw]=au[aw])}ar=ar.replace(av);aB=av[aB]}var at=ar.toString();try{return(new Function(aB,at)).call(au["this"],au)}catch(ay){throw new Error((ay.message||ay)+" while compiling "+at)}};an.gensym_rename_table=function(aA){var az={},ax=[];aA.reach(function(aB){var aC=aB.data;if(W(aC)){az[aC]||ax.push(aC)}az[aC]=aC.replace(/^(.*)_[a-z0-9]+_.{22}$/,"$1")||"anon"});var ar={},ay=function(aB){if(!(aB in az)){return aB}var aC=ar[aB]||0;while(az[aB+(++aC).toString(36)]){}return aB+(ar[aB]=aC).toString(36)};for(var at={},av=0,au=ax.length,aw;av<au;++av){at[aw=ax[av]]||(az[at[aw]=ay(az[aw])]=true)}return at}})();var M=function(ap){for(var aq=ap.split(/\s+/),ar=1,ao=aq.length,at=an[aq[0]]();ar<ao;++ar){at=an[aq[ar]](at)}return at};an.init=function(ap){ap||(ap=function(aq){return true});ap.constructor===Function||(ap=M(ap));var ao=function(at,aq,ar){return at.constructor===Function||at.constructor===String?an.compile(ao.call(ao,an.parse(at)),aq,ar):at.rmap(function(au){return ap.call(ao,au,aq,ar)})};ao.global=an;ao.macroexpander=ap;return ao};an.initializer=f;an.clone=function(){return C(f(f,c).deglobalize(),function(){for(var ao in an){this[ao]||(this[ao]=an[ao])}})};return caterwaul=an});
(caterwaul.std_initializer=function(){(function($){var syntax_manipulator=function(base_case){var result=function(x){if(x.constructor===Array){for(var i=0,l=x.length,ys=[];i<l;++i){ys.push(result(x[i]))}return function(tree){for(var i=ys.length-1,r;i>=0;--i){if(r=ys[i].call(this,tree)){return r}}}}else{return x.constructor===String?result($.parse(x)):x.constructor===$.syntax?base_case.call(this,x):x}};return result};$.pattern=syntax_manipulator(function(pattern){return function(tree){return pattern.match(tree)}});$.expander=syntax_manipulator(function(expander){return function(match){return expander.replace(match)}});$.alternatives=syntax_manipulator(function(alternative){throw new Error("must use replacer functions with caterwaul.alternatives()")});$.reexpander=function(expander){var e=$.expander(expander);return function(match){var r=e.call(this,match);return r&&this(r)}};var composer=function(expander_base_case){return function(pattern,expander){var new_pattern=$.pattern(pattern),new_expander=expander_base_case(expander);return function(tree){var match=new_pattern.call(this,tree);return match&&new_expander.call(this,match)}}};$.replacer=composer($.expander);$.rereplacer=composer($.reexpander);$.macroexpand=function(tree){return $($.alternatives(Array.prototype.slice.call(arguments,1)))(tree)}})(caterwaul);(function($){$.anonymizer=function(){for(var translation_table={},i=0,l=arguments.length;i<l;++i){translation_table[arguments[i]]=$.gensym(arguments[i])}return function(node){return $.parse(node).replace(translation_table)}}})(caterwaul);(function($){$.js=function(macroexpander){var string_interpolator=function(node){var s=node.data,q=s.charAt(0),syntax=$.syntax;if(q!=="'"&&q!=='"'||!/#\{[^\}]+\}/.test(s)){return false}for(var pieces=[],is_code=[],i=1,l=s.length-1,brace_depth=0,got_hash=false,start=1,c;i<l;++i){if(brace_depth){if((c=s.charAt(i))==="}"){--brace_depth||(pieces.push(s.substring(start,i)),is_code.push(true))&&(start=i+1),got_hash=false}else{brace_depth+=c==="{"}}else{if((c=s.charAt(i))==="#"){got_hash=true}else{if(c==="{"&&got_hash){pieces.push(s.substring(start,i-1)),is_code.push(false),start=i+1,++brace_depth}else{got_hash=false}}}}pieces.push(s.substring(start,l)),is_code.push(false);for(var quoted=new RegExp("\\\\"+q,"g"),i=0,l=pieces.length;i<l;++i){pieces[i]=is_code[i]?this($.parse(pieces[i].replace(quoted,q)).as("(")):new syntax(q+pieces[i]+q)}return new syntax("+",pieces).unflatten().as("(")};var function_local_template=$.parse("var _x = _y"),function_bind_pattern=$.parse("_x = _y"),function_result_pattern=$.parse("result"),function_with_afters=$.parse("function (_formals) {_befores; var result = _result; _afters; return result}"),function_without_afters=$.parse("function (_formals) {_befores; return _result}"),function_assignment_template=$.parse("_f = _x"),function_is_result=function(n){return n.is_empty()&&n.data==="result"},function_destructure=$.rereplacer("_f(_xs) = _y",function(match){for(var formals=[],befores=[],afters=[],ps=match._xs.flatten(","),i=0,l=ps.length;i<l;++i){(afters.length||ps[i].contains(function_is_result)?afters:befores.length||ps[i].length?befores:formals).push(ps[i])}for(var contains_locals=[befores,afters],i=0,l=contains_locals.length;i<l;++i){for(var xs=contains_locals[i],j=0,lj=xs.length,m;j<lj;++j){xs[j]=(m=function_bind_pattern.match(xs[j]))&&m._x.is_empty()?function_local_template.replace(m):xs[j].as("(")}}var new_formals=formals.length?new $.syntax(",",formals).unflatten():$.empty,new_befores=befores.length?new $.syntax(";",befores).unflatten():$.empty,new_afters=afters.length?new $.syntax(";",afters).unflatten():$.empty;template=function_assignment_template.replace({_f:match._f,_x:afters.length?function_with_afters:function_without_afters});return template.replace({_formals:new_formals,_befores:new_befores,_afters:new_afters,_result:match._y})});var infix_function=function(node){var d=node.data,left,fn;if((d==="/"||d==="|")&&(left=node[0]).data===d&&left[1]&&left[1].data==="u-"&&(fn=left[1][0])){return new $.syntax("()",fn,this(node[0][0]).flatten(d).push(this(node[1])).with_data(",").unflatten())}};var infix_method=function(node){var d=node.data,left,fn;if((d==="/"||d==="|")&&(left=node[0]).data===d&&left[1]&&left[1].data==="u~"&&(fn=left[1][0])){var xs=[].slice.call(this(node[0][0]).flatten(d)),object=xs.shift();return new $.syntax("()",new $.syntax(".",new $.syntax("(",object),fn),new $.syntax(",",xs,this(node[1])).unflatten())}};var postfix_function_template=$.parse("_f(_x)"),postfix_function=$.rereplacer("_x /!_f",function(match){return postfix_function_template.replace({_f:match._f,_x:this(match._x).flatten("/").with_data(",").unflatten()})});var modified_literal_form=$.pattern("_literal._modifier"),lookup_literal_modifier=function(caterwaul,type,modifier){var hash=caterwaul.literal_modifiers[type];return hash.hasOwnProperty(modifier)&&hash[modifier]},literal_modifier=function(node){var modified_literal=modified_literal_form.call(this,node),literal,expander;if(modified_literal&&(literal=modified_literal._literal)&&(expander=literal.is_identifier()?lookup_literal_modifier(this,"identifier",modified_literal._modifier.data):literal.is_array()?lookup_literal_modifier(this,"array",modified_literal._modifier.data):literal.is_regexp()?lookup_literal_modifier(this,"regexp",modified_literal._modifier.data):literal.is_number()?lookup_literal_modifier(this,"number",modified_literal._modifier.data):literal.is_string()?lookup_literal_modifier(this,"string",modified_literal._modifier.data):null)){return expander.call(this,literal)}};var bracket_modifier_form=$.pattern("_modifier[_expression]"),slash_modifier_form=$.pattern("_expression /_modifier"),minus_modifier_form=$.pattern("_expression -_modifier"),in_modifier_form=$.pattern("_modifier in _expression"),pipe_modifier_form=$.pattern("_expression |_modifier"),comma_modifier_form=$.pattern("_expression, _modifier"),dot_parameters=$.pattern("_modifier._parameters"),bracket_parameters=$.pattern("_modifier[_parameters]"),parameterized_wickets=$.pattern("_expression <_modifier> _parameters"),parameterized_minus=$.pattern("_expression -_modifier- _parameters"),modifier=function(node){var modifier,parameterized_match=parameterized_wickets.call(this,node)||parameterized_minus.call(this,node);if(parameterized_match&&this.parameterized_modifiers.hasOwnProperty(modifier=parameterized_match._modifier.data)){var r=this.parameterized_modifiers[modifier].call(this,parameterized_match);if(r){return r}}var regular_match=bracket_modifier_form.call(this,node)||slash_modifier_form.call(this,node)||minus_modifier_form.call(this,node)||in_modifier_form.call(this,node)||pipe_modifier_form.call(this,node)||comma_modifier_form.call(this,node);if(regular_match){var parameter_match=dot_parameters.call(this,regular_match._modifier)||bracket_parameters.call(this,regular_match._modifier);if(parameter_match){regular_match._modifier=parameter_match._modifier;regular_match._parameters=parameter_match._parameters;return this.parameterized_modifiers.hasOwnProperty(modifier=regular_match._modifier.data)&&this.parameterized_modifiers[modifier].call(this,regular_match)}else{return this.modifiers.hasOwnProperty(modifier=regular_match._modifier.data)&&this.modifiers[modifier].call(this,regular_match)}}};var each_node=function(node){return string_interpolator.call(this,node)||literal_modifier.call(this,node)||node.length&&(modifier.call(this,node)||function_destructure.call(this,node)||infix_function.call(this,node)||infix_method.call(this,node)||postfix_function.call(this,node))},result=macroexpander?$(function(node){return macroexpander.call(this,node)||each_node.call(this,node)}):$(each_node);result.modifiers={};result.parameterized_modifiers={};result.literal_modifiers={regexp:{},array:{},string:{},number:{},identifier:{}};return result}})(caterwaul);(function($){$.js_literals=function(caterwaul_function){var function_template=$.parse("function (_) {return _body}");(function(r){r.x=$.reexpander(function(node){return node.with_data(node.data.replace(/\s+/g,""))});var call_exec_template=$.parse("_regexp.exec(_)");r.qf=function(node){return function_template.replace({_body:call_exec_template.replace({_regexp:node})})}})(caterwaul_function.literal_modifiers.regexp);(function(s){s.qw=$.reexpander(function(node){for(var array_node=new $.syntax("["),comma=new $.syntax(","),delimiter=node.data.charAt(0),pieces=node.as_escaped_string().split(/\s+/),i=0,l=pieces.length;i<l;++i){comma.push(new $.syntax(delimiter+pieces[i]+delimiter))}return array_node.push(comma.unflatten())});s.qh=$.reexpander(function(node){for(var hash_node=new $.syntax("{"),comma=new $.syntax(","),delimiter=node.data.charAt(0),pieces=node.as_escaped_string().split(/\s+/),i=0,l=pieces.length;i<l;i+=2){comma.push(new $.syntax(":",new $.syntax(delimiter+pieces[i]+delimiter),new $.syntax(delimiter+pieces[i+1]+delimiter)))}return hash_node.push(comma.unflatten())});s.qr=$.reexpander(function(node){return node.with_data("/"+node.as_escaped_string().replace(/\//g,"\\/")+"/")});s.qs=function(node){return new $.ref($.parse(node.as_unescaped_string()))};s.qf=$.reexpander(function(node){return function_template.replace({_body:$.parse(node.as_unescaped_string())})})})(caterwaul_function.literal_modifiers.string);return caterwaul_function}})(caterwaul);(function($){var scope_template=$.parse("(function () {var _variables; return (_expression)}).call(this)");$.words=function(caterwaul_function){$.merge(caterwaul_function.modifiers,$.words.modifiers);$.merge(caterwaul_function.parameterized_modifiers,$.words.parameterized_modifiers);return caterwaul_function};$.words.modifiers={qs:function(match){return new $.ref(match._expression,"qs")},qse:function(match){return new $.ref(this(match._expression),"qse")},reexpand:function(match){return this(this(match._expression))},noexpand:function(match){return match._expression},raise:$.reexpander("(function () {throw _expression}).call(this)"),eval:function(match){return new $.ref($.compile(this(match._expression)),"eval")},delay:$.reexpander("(function (t, f) {return (function () {return f.call(t)})})(this, (function () {return _expression}))"),lazy:$.reexpander("(function (t, f, v, vc) {return (function () {return vc ? v : (vc = true, v = f.call(t))})})(this, (function () {return _expression}))"),capture:function(match){for(var comma=new $.syntax(","),bindings=match._expression.flatten(","),i=0,l=bindings.length;i<l;++i){comma.push(this(bindings[i]).with_data(":"))}return new $.syntax("{",comma.unflatten())},wcapture:function(match){for(var e=this(match._expression),comma=new $.syntax(","),bindings=e.flatten(","),node,i=0,l=bindings.length;i<l;++i){(node=this(bindings[i]))[1]=node[0],comma.push(node.with_data(":"))}return scope_template.replace({_variables:e,_expression:new $.syntax("{",comma.unflatten())})}};$.words.parameterized_modifiers={given:$.reexpander("(function (_parameters) {return _expression})"),bgiven:$.reexpander("(function (t, f) {return (function () {return f.apply(t, arguments)})})(this, (function (_parameters) {return _expression}))"),rescue:$.reexpander("(function () {try {return (_expression)} catch (e) {return (_parameters)}}).call(this)"),se:$.reexpander("(function (it) {return (_parameters), it}).call(this, (_expression))"),re:$.reexpander("(function (it) {return (_parameters)}).call(this, (_expression))"),where:$.reexpander("(function () {var _parameters; return (_expression)}).call(this)"),using:$.reexpander(function(match){var o=$.compile(this(match._parameters)),comma=new $.syntax(",");for(var k in o){if(Object.prototype.hasOwnProperty.call(o,k)){comma.push(new $.syntax("=",k,new $.ref(o[k])))}}return scope_template.replace({_variables:comma.unflatten(),_expression:match._expression})}),when:$.reexpander("((_parameters) && (_expression))"),and:$.reexpander("((_expression) && (_parameters))"),unless:$.reexpander("(! (_parameters) && (_expression))"),or:$.reexpander("((_expression) || (_parameters))")}})(caterwaul);caterwaul.words(caterwaul.js())(function($){$.seq(caterwaul_function)=caterwaul_function-se[it.modifiers.seq(match)=seq_expand.call(seq_expand,anon_pattern.replace({_x:match._expression}))-re-this(it)/when.it]-where[anon_pattern=anon("S[_x]"),seq_expand=$($.alternatives(operator_macros.concat(word_macros)))],where[anon=$.anonymizer("S"),rule(p,e)=$.rereplacer(p.constructor===String?anon(p):p,e.constructor===String?anon(e):e),operator_macros=[rule("S[_x]","_x"),rule("S[_xs + _ys]",concat),rule("S[_xs ^ _ys]",zip),rule("S[_xs - _ys]",cross),rule("S[(_x)]","(S[_x])"),rule("S[_x[_y]]","S[_x][_y]"),rule("S[_xs(_ys)]","S[_xs](_ys)"),rule("S[[_x]]","[_x]"),rule("S[_x, _y]","S[_x], S[_y]"),rule("S[_xs._p]","S[_xs]._p"),rule("S[~[_x]]","[S[_x]]"),rule("S[~_xs(_ys)]","S[_xs](S[_ys])"),rule("S[_x ? _y : _z]","(S[_x]) ? (S[_y]) : (S[_z])"),rule("S[_x && _y]","(S[_x]) && (S[_y])"),rule("S[_x || _y]","(S[_x]) || (S[_y])"),rule("S[+_xs]","Array.prototype.slice.call((_xs))"),rule("S[_xs %_thing]",handle_filter_forms),rule("S[_xs *_thing]",handle_map_forms),rule("S[_xs /_thing]",handle_fold_forms),rule("S[_xs |_thing]",handle_exists_forms),rule("S[_xs %k*_thing]",handle_kmap_forms),rule("S[_xs %v*_thing]",handle_vmap_forms),rule("S[_xs %k%_thing]",handle_kfilter_forms),rule("S[_xs %v%_thing]",handle_vfilter_forms)]-where[unrecognized(reason)=raise[new Error(reason)],use_form(form,xs,body,init,vars)=form?form.replace({_f:body,_init:init}).replace($.merge({_s:xs},vars)):unrecognized("unsupported sequence operator or modifiers used on #{body}"),operator_case(forms)(match)=parse_modifiers(match._thing,use(forms.normal,forms.inormal),use(forms.bang,forms.ibang),use(forms.tbang,forms.itbang))-where[xs=match._xs,expander=this,form_function(form)(body,vars)=use_form(form,xs,body,null,vars),iform_function(form)(body,init,vars)=use_form(form,xs,body,init,vars),use(form,iform)(body)=parse_body(body,expander,form_function(form),iform_function(iform))],handle_map_forms=operator_case({normal:map,bang:each,tbang:flatmap,itbang:iterate}),handle_filter_forms=operator_case({normal:filter,bang:filter_not,tbang:map_filter,itbang:imap_filter}),handle_fold_forms=operator_case({normal:foldl,bang:foldr,tbang:unfold,inormal:ifoldl,ibang:ifoldr,itbang:iunfold}),handle_kmap_forms=operator_case({normal:kmap,bang:keach}),handle_kfilter_forms=operator_case({normal:kfilter,bang:kfilter_not,tbang:kmap_filter}),handle_vmap_forms=operator_case({normal:vmap,bang:veach}),handle_vfilter_forms=operator_case({normal:vfilter,bang:vfilter_not,tbang:vmap_filter}),handle_exists_forms=operator_case({normal:exists,bang:not_exists}),block=anon("[_x]"),block_with_variable=anon("_var[_x]"),block_with_init=anon("[_init][_x]"),block_with_variable_and_init=anon("_var[_init][_x]"),block_with_closure=anon("+_x"),block_with_seq=anon("~_x"),standard_names={_x:"x",_x0:"x0",_xi:"xi",_xl:"xl",_xs:"xs",_xr:"xr"},prefixed_names(p)={_x:p,_x0:"#{p}0",_xi:"#{p}i",_xl:"#{p}l",_xs:"#{p}s",_xr:"#{p}r"},function_promotion=anon("(_f).call({_x0: _x0, _xi: _xi, _xl: _xl, _xs: _xs, _xr: _xr}, _x)"),promote_function(f)=function_promotion.replace({_f:f}),closure_wrapper=anon("(function (_x, _x0, _xi, _xl, _xs, _xr) {return _f}).call(this, _x, _x0, _xi, _xl, _xs, _xr)"),close_body(vars,f)=closure_wrapper.replace(vars).replace({_f:f}),seq_pattern=anon("S[_x]"),promote_seq(f)=seq_pattern.replace({_x:f}),parse_body(tree,expand,normal,init)=((r=block_with_seq.match(tree))?parse_body(r._x,expand,sequence_context_normal,sequence_context_init):(r=block_with_closure.match(tree))?parse_body(r._x,expand,wrapping_normal,wrapping_init):(r=block_with_variable_and_init.match(tree))?init(r._x,r._init,prefixed_names(r._var)):(r=block_with_init.match(tree))?init(r._x,r._init,standard_names):(r=block_with_variable.match(tree))?normal(r._x,prefixed_names(r._var)):(r=block.match(tree))?normal(r._x,standard_names):normal(promote_function(tree),standard_names))-where[in_sequence_context(f)=expand.call(expand,promote_seq(f)),sequence_context_normal(f,names)=normal(in_sequence_context(f),names),sequence_context_init(f,init_expression,names)=init(in_sequence_context(f),init_expression,names),wrapping_normal(f,names)=normal(close_body(names,f),names),wrapping_init(f,init_expression,names)=init(close_body(names,f),init_expression,names),r=null],tbang_modifier=anon("~!_x"),bang_modifier=anon("!_x"),parse_modifiers(tree,normal,bang,tbang)=((result=tbang_modifier.match(tree))?tbang(result._x):(result=bang_modifier.match(tree))?bang(result._x):normal(tree))-where[result=null]]-where[loop_anon=$.anonymizer("x","y","i","j","l","lj","r","o","k"),scope=anon("(function (_xs) {var _x, _x0, _xi, _xl, _xr; _body}).call(this, S[_s])"),scoped(t)=scope.replace({_body:t}),expand(s)=s.replace(/@/g,"Array.prototype.slice.call").replace(/#/g,"Object.prototype.hasOwnProperty.call").replace(/%%/g,".constructor"),form(x)=x/!expand/!anon/!scoped/!loop_anon,map=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length; _xi < _xl; ++_xi) _x = _xs[_xi], _xr.push((_f));               return _xr"),each=form("for (var                    _xi = 0, _xl = _xs.length; _xi < _xl; ++_xi) _x = _xs[_xi], (_f);                         return _xs"),flatmap=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length; _xi < _xl; ++_xi) _x = _xs[_xi], _xr.push.apply(_xr, @((_f))); return _xr"),iterate=form("for (var _x = _xs, _xi = 0, _x0, _xl;              _x0 = (_init); ++_xi) _x = (_f);                                   return _x"),filter=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length, _x0;     _xi < _xl; ++_xi) _x = _xs[_xi], (_f) && _xr.push(_x);        return _xr"),filter_not=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length, _x0;     _xi < _xl; ++_xi) _x = _xs[_xi], (_f) || _xr.push(_x);        return _xr"),map_filter=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length, _x0, _y; _xi < _xl; ++_xi) _x = _xs[_xi], (_y = (_f)) && _xr.push(_y); return _xr"),imap_filter=form("for (var _xr = new _xs%%(), _xi = 0, _xl = _xs.length, _x0; _xi < _xl; ++_xi) _x = _xs[_xi], (_x0 = (_init)) && _xr.push(_f); return _xr"),foldl=form("for (var _x0 = _xs[0], _xi = 1, _xl = _xs.length;            _xi < _xl; ++_xi) _x = _xs[_xi], _x0 = (_f); return _x0"),foldr=form("for (var _xl = _xs.length, _xi = _xl - 2, _x0 = _xs[_xl - 1]; _xi >= 0; --_xi) _x = _xs[_xi], _x0 = (_f); return _x0"),unfold=form("for (var _xr = [], _x = _xs, _xi = 0;                      _x !== null; ++_xi) _xr.push(_x), _x = (_f);   return _xr"),ifoldl=form("for (var _x0 = (_init), _xi = 0, _xl = _xs.length;      _xi < _xl; ++_xi) _x = _xs[_xi], _x0 = (_f);     return _x0"),ifoldr=form("for (var _xl = _xs.length - 1, _xi = _xl, _x0 = (_init); _xi >= 0; --_xi) _x = _xs[_xi], _x0 = (_f);     return _x0"),iunfold=form("for (var _xr = [], _x = _xs, _xi = 0, _x0;          _x0 = (_init); ++_xi) _xr.push(_x), _x = (_f);       return _xr"),exists=form("for (var _x = _xs[0], _xi = 0, _xl = _xs.length, x; _xi < _xl; ++_xi) {_x = _xs[_xi]; if (x = (_f)) return x} return false"),not_exists=form("for (var _x = _xs[0], _xi = 0, _xl = _xs.length, x; _xi < _xl; ++_xi) {_x = _xs[_xi]; if (x = (_f)) return false} return true"),concat=anon("(S[_xs]).concat((S[_ys]))"),zip=form("for (var _xr = (S[_ys]), pairs = [], i = 0, l = _xs.length; i < l; ++i) pairs.push([_xs[i], _xr[i]]); return pairs"),cross=form("for (var _xr = (S[_ys]), pairs = [], i = 0, l = _xs.length, lj = _xr.length; i < l; ++i) for (var j = 0; j < lj; ++j) pairs.push([_xs[i], _xr[j]]);return pairs"),kmap=form("var _xr = new _xs%%();  for (var _x in _xs) if (#(_xs, _x)) _xr[_f] = _xs[_x]; return _xr"),keach=form("                        for (var _x in _xs) if (#(_xs, _x)) _f;                return _xs"),kfilter=form("var _xr = new _xs%%();    for (var _x in _xs) if (#(_xs, _x) &&      (_f))  _xr[_x] = _xs[_x]; return _xr"),kfilter_not=form("var _xr = new _xs%%();    for (var _x in _xs) if (#(_xs, _x) &&    ! (_f))  _xr[_x] = _xs[_x]; return _xr"),kmap_filter=form("var _xr = new _xs%%(), x; for (var _x in _xs) if (#(_xs, _x) && (x = (_f))) _xr[x]  = _xs[_x]; return _xr"),vmap=form("var _xr = new _xs%%();    for (var  k in _xs) if (#(_xs, k)) _x = _xs[k], _xr[k] = (_f); return _xr"),veach=form("                          for (var  k in _xs) if (#(_xs, k)) _x = _xs[k], _f;            return _xs"),vfilter=form("var _xr = new _xs%%();    for (var  k in _xs) if (#(_xs, k)) _x = _xs[k],        (_f) && (_xr[k] = _x); return _xr"),vfilter_not=form("var _xr = new _xs%%();    for (var  k in _xs) if (#(_xs, k)) _x = _xs[k],        (_f) || (_xr[k] = _x); return _xr"),vmap_filter=form("var _xr = new _xs%%(), x; for (var  k in _xs) if (#(_xs, k)) _x = _xs[k], x = (_f), x && (_xr[k] =  x); return _xr")],word_macros=[rule("S[n[_upper]]",n),rule("S[ni[_upper]]",ni),rule("S[_o /keys]",keys),rule("S[_o |object]",object),rule("S[n[_lower, _upper]]",n),rule("S[ni[_lower, _upper]]",ni),rule("S[_o /values]",values),rule("S[_o -object]",object),rule("S[n[_lower, _upper, _step]]",n),rule("S[ni[_lower, _upper, _step]]",ni),rule("S[_o /pairs]",pairs),rule("S[_o /object]",object)]-where[n(match)=n_pattern.replace($.merge({_lower:"0",_step:"1"},match)),ni(match)=ni_pattern.replace($.merge({_lower:"0",_step:"1"},match)),n_pattern=anon("(function (i, u, s) {if ((u - i) * s <= 0) return [];for (var r = [], d = u - i; d > 0 ? i <  u : i >  u; i += s) r.push(i); return r})((_lower), (_upper), (_step))"),ni_pattern=anon("(function (i, u, s) {if ((u - i) * s <= 0) return [];for (var r = [], d = u - i; d > 0 ? i <= u : i >= u; i += s) r.push(i); return r})((_lower), (_upper), (_step))"),scope=anon("(function (o) {_body}).call(this, (S[_o]))"),scoped(t)=scope.replace({_body:t}),form(p)=tree.replace(match)-given.match-where[tree=scoped(anon(p))],keys=form("var ks = []; for (var k in o) Object.prototype.hasOwnProperty.call(o, k) && ks.push(k); return ks"),values=form("var vs = []; for (var k in o) Object.prototype.hasOwnProperty.call(o, k) && vs.push(o[k]); return vs"),pairs=form("var ps = []; for (var k in o) Object.prototype.hasOwnProperty.call(o, k) && ps.push([k, o[k]]); return ps"),object=form("for (var r = {}, i = 0, l = o.length, x; i < l; ++i) x = o[i], r[x[0]] = x[1]; return r")]]})(caterwaul);caterwaul.js_all=function(){return this.seq(this.words(this.js_literals(this.js())))}})();

// Generated by SDoc 





// Module loading code.
// This is where your modules get loaded into the REPL. This script is included by sdoc::js::repl and is used to render into HTML for cross-browser testing.

// modules go here

// Caterwaul serialization support | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This project is a reimplementation of Rather Insane Serialization (github.com/spencertipping/rather-insane-serialization) for Caterwaul. In addition to the functionality implemented in Rather
// Insane Serialization, this project also provides support for opaque references, which are associated with a specific serialization stream. This is useful for dealing with non-serializable
// values that are intermixed with normal ones. The most common use case for this is probably sending DOM nodes or jQuery collections to a server and then resolving them back into local objects
// when they reach the client again. This serialization library encodes the object's opaque identity whenever a reference is used; that way you have the property that for any reference X,
// deserialize(serialize(X)) === X. (This is true even if X changes state between serialization and deserialization.)

caterwaul('js_all')(function ($) {

// Serialization format.
// Serialized values are encoded into JSON data; the end result is something that you can invoke JSON.stringify() on to get a string. (You could also translate the data structure into XML or some
// other format prior to string conversion.) My initial inclination was to use a bytecode format similar to the one used by Rather Insane Serialization, but JSON is ultimately a more flexible
// solution and is easier to implement. It is probably also more performant in some cases.

// Like before, an object graph is used. The toplevel data structure is an array containing elements whose position determines their identity. The first nine logical elements are implied:

// | 0. undefined
//   1. null
//   2. value-type false
//   3. value-type true
//   4. value-type NaN
//   5. value-type -Infinity
//   6. value-type +Infinity
//   7. value-type 0
//   8. value-type '' (empty string)

// Each entry within the toplevel array corresponds to a logical piece of data, and as such it has a type tag to indicate its role. The exceptions are for primitive numeric and string values,
// which are encoded verbatim. (The rationale is that they are supported by any marginally competent serialization layer such as JSON.) The type tags are:

// | 0. Unknown (used for opaque value encoding)
//   1. Reference boolean
//   2. Reference number
//   3. Reference string
//   4. Array
//   5. Object
//   6. Date
//   7. Regexp
//   8. Function (no closure support, unfortunately; but local referencing is used)

// The last entry in the toplevel array is a numeric reference to the original value that was serialized.

// References.
// A reference is encoded using a 4-tuple of its type, a key referring to its local instance, a type-specific structural value, and a list of property links. The type flag is one of the magic
// numbers above. Local instance identifiers have at least 128 bits of random entropy and are base-62 strings; this prevents collisions when a value is run through several streams and makes it
// more difficult (though not impossible, if you have information about the random number generator) to exploit clients by referring to values from other messages.

// Type-specific values are arrays, strings, or numbers. They are:

// | 0. For an unknown: the empty array
//   1. For a reference Boolean: a numeric reference to a primitive boolean
//   2. For a reference Number: a numeric reference to a primitive number
//   3. For a reference String: a numeric reference to a primitive string
//   4. For an array: an array of numeric references to its elements
//   5. For an object: the empty array
//   6. For a Date: a numeric reference to its numeric coercion (its UTC value in milliseconds, I believe)
//   7. For a Regexp: a numeric reference to its toString() representation
//   8. For a function: a numeric reference to its source code as a string

// So, for example:

// | encode(new Boolean(true))     -> [[1, 'local id', 3, []], 9]
//   encode([1, 'foo'])            -> [[4, 'local id', [10, 11], []], 1, 'foo', 9]

// Notice that all of the indexes are shifted up by 9; so the index of the first element of the serializer output is 9, not 0. This happens because of the preloaded constant table. The first nine
// indexes refer to those, and the array works as though they were prepended to it. (This is actually responsible for a nontrivial amount of machinery in the decoder; see ref(xs, index) for
// example.)

// Linking.
// Once the 4-tuple is allocated in the toplevel array, the encoder searches the original object for property links. (For arrays, this includes a step to populate the list of numerically-indexed
// values; these are excluded from the main link table for performance and Javascript-pathology reasons.) Links are stored in an array of implied 2-tuples. For example:

// | encode({foo: 'bar', bif: 'baz'})      -> [[5, 'local id', [], [10, 11, 12, 13]], 'foo', 'bar', 'bif', 'baz', 9]

// In this case, the array [10, 11, 12, 13] should be interpreted as [[10, 11], [12, 13]] (this is responsible for the sketchy explicit ++xi happening in the decoder), but isn't encoded that way
// for performance and space reasons. I didn't benchmark this, by the way. I just felt like a bit of premature optimization.

// Unknowns.
// There's some interesting stuff going on with unknown values. An unknown is what you get when you decode something that this library doesn't know how to encode. For instance, if you encode
// 'document' on a browser and decode it somewhere else (such as in a node.js process), you'll get an unknown where the document was. The following properties are true of unknowns:

// | 1. Their original properties are linked, provided that they satisfy hasOwnProperty().
//   2. Encoding a non-serializable value with one stream and decoding it with another produces an unknown.
//   3. An unknown can be encoded using any stream and decoded with the original to restore the original reference.

// Most of these things follow from the fact that an unknown has a constant local key. This means that other streams are required to respect its identity and preserve it across serialization and
// deserialization (unless one of those streams contains a mapping for it, in which case the original value is restored). Unknowns bypass the linking step.

  $.serialization = stream /-$.merge/ statics -where [

    statics                                       = capture [unknown = "this -se [it.id = _]".qf -se [it.prototype /-$.merge/ capture [toString() = '<#unknown #{this.id}>']]],

    base62_characters                             = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    key()                                         = n[22] *[base62_characters.charAt(Math.random() * 62 >>> 0)] -seq -re- '_#{it.join("")}',
    precoded_values                               = [void 0, null, false, true, ''/'', -1/0, 1/0, 0, ''],
    structural_reference_types                    = [Boolean, Number, String, Array, Object, Date, RegExp, Function],

    shift                                         = precoded_values.length,
    shift1                                        = shift - 1,

    encoder(locals, k, xs, c, encode = result)(v) = position_of(v) -or- store(v) -re- +it
                                            -where [ref_detector          = new String(key()),
                                                    is_precoded(v)        = !v || v.constructor === Number && !isFinite(v) -or- isNaN(v) || v === true,
                                                    is_reference(v)       = ['object', 'function'] /~indexOf/ typeof v !== -1,

                                                    precoded_index_of(v)  = precoded_values /~indexOf/ v -re [it === -1 && isNaN(v) ? 4 : it],

                                                    is_unknown(v)         = v.constructor === $.serialization.unknown,
                                                    local_key_for(v)      = v /!is_unknown ? v.id : key(),
                                                    position_of(v)        = v /!is_precoded ? new Number(precoded_index_of(v)) : v /!is_reference ? v[k] : c['@#{(typeof v).charAt(0)}#{v}'],
                                                    store(v)              = v /!is_reference ? store_reference(locals[k] = v, k) -where [k = local_key_for(v)] -se- visit(v)
                                                                                             : c['@#{(typeof v).charAt(0)}#{v}'] = shift1 + xs /~push/ v,

                                                    store_reference(v, i) = v[k] = shift1 + xs /~push/ [type_of(v), i, value_of(v), []],

                                                    type_of(v)            = structural_reference_types /~indexOf/ v.constructor + 1,
                                                    value_of(v)           = v.constructor === Boolean || v.constructor === Number || v.constructor === Date     ? encode(v.valueOf()) :
                                                                            v.constructor === String  || v.constructor === RegExp || v.constructor === Function ? encode(v.toString()) : [],

                                                    visit(v)              = link_properties(v, is_array) -se- link_array_elements(v) /when.is_array -unless- v /!is_unknown
                                                                    -where [is_array                     = v instanceof Array,
                                                                            ref                          = xs[position_of(v) - shift],
                                                                            encode_pair(p)               = ref[3] / encode(p[0]) /~push/ encode(p[1]),

                                                                            is_array_index(v, p)         = /^\d+$/.test(p) && +p >= 0 && +p < v.length,
                                                                            link_properties(v, is_array) = v /pairs %[x[0] !== k && !is_array -or- !is_array_index(v, x[0])] *!encode_pair -seq,
                                                                            link_array_elements(v)       = ref[2] = +v *encode -seq]],
    decode(locals, xs) = ref(values, values.pop())
                 -where [was_local                     = {},
                         reconstitute(o, i)            = o.constructor === Array ? (was_local[i] = locals[o[1]]) || reconstitute_reference(o, xs) : o,
                         reconstitute_reference(o)     = o[0] === 4        ? [] :
                                                         o[0] === 8        ? safely_rebuild_function(xs /-ref/ o[2]) :
                                                         o[0] === 7        ? /^\/(.*)\/([^\/]*)$/.exec(xs /-ref/ o[2]) -re [new RegExp(it[1], it[2])] :
                                                         o[0] && o[0] <= 8 ? new structural_reference_types[o[0] - 1](xs /-ref/ o[2]) :
                                                                             new $.serialization.unknown(o[1]),

                         ref(xs, index)                = index >= shift ? xs[index - shift] : precoded_values[index],

                         safely_rebuild_function(code) = $ /~compile/ parsed
                                                  -when [parsed /!looks_like_a_function || parsed[0].data === '(' && parsed[0] /!looks_like_a_function]
                                                 -where [parsed                   = $ /~parse/ code,
                                                         looks_like_a_function(t) = t.data === 'function' && t[0].data === '(' && t[1].data === '{'],

                         relink(serialized, objects)   = serialized *!link_object_properties *!link_array_properties -seq
                                                 -where [has_links(x)                                    = x.constructor === Array && !was_local[this.xi],
                                                         has_indexes(x)                                  = x /!has_links && x[0] === 4,
                                                         link_object_properties(s, o = objects[this.xi]) = s[3] *![o[objects /-ref/ x] = objects /-ref/ xs[++xi]] -seq -when- s /!has_links,
                                                         link_array_properties (s, o = objects[this.xi]) = s[2] *![o.push(objects /-ref/ x)]                      -seq -when- s /!has_indexes],

                         values                        = xs *[reconstitute(x, xi)] -seq -se- relink(xs, it)],

    stream(self = result) = "self /~encode/ _".qf /-$.merge/ capture [locals    = {},
                                                                      encode(v) = xs /~push/ value_index -re- xs
                                                                          -where [k           = key(),
                                                                                  xs          = [],
                                                                                  unmark(xs)  = xs %[x.constructor === Array] *![delete self.locals[x[1]][k]] -seq,
                                                                                  value_index = encoder(self.locals, k, xs, {})(v) -se- unmark(xs)],

                                                                      decode(v) = decode(self.locals, v)]]})(caterwaul);

// Generated by SDoc 


// Generated by SDoc 




var t = function () {$('body').append($('<div>').text(Array.prototype.join.call(arguments, ', ') + ' -> ' + test_case.apply(this, arguments)))};

$(function () {


// Unit tests.
// These are quick, visible assertions to make sure that the setup works properly. The test_case function is called automatically by t(), which is customized to work on whatever platform you're
// running under (e.g. node.js or a browser).

caterwaul('js_all')(function ($) {
  test_case(x) = '#{json(x)} -> #{json(encoded)} -> (#{decoded2}) #{json(decoded2)}'
            -se- console.log('\033[1;31mSerialization failed to use abstract reference for #{x}\033[0;0m') /unless [decoded1 === x]
            -se- console.log('\033[1;31mSerialization failed to preserve JSON for #{x}\033[0;0m')          /unless [json(x) === json(decoded2)]
            -se- console.log('\033[1;31mSerialization failed to preserve constructor for #{x}\033[0;0m')   /unless [decoded1.constructor === decoded2.constructor] /when.decoded1
         -where [s        = caterwaul.serialization(), encoded  = s(x),
                 decoded1 = s.decode(encoded),         decoded2 = s.decode(encoded)],

  // Preloaded cases
  mt(undefined, null, true, false, Infinity, -Infinity, 0),

  // Primitives
  mt('', 'toString', 'foo bar\u0000', 1, 1.1, Math.PI),

  // Reference types
  mt(new String(''), new String('foo'), new Number(10), new Boolean(true), new Boolean(false)),

  // Structural reference types
  mt(/foo/, /bar/g, /bif/mig, new Date(), new Date(0), function (x) {return x + 1}, function () {}, function (x) {}, function () {return this}),

  // Objects and arrays
  mt([], [1, 2, 3], [1], [null], [[]], [undefined], [true, false, NaN], [{}], [new String('foo')]),
  mt({}, {foo: 'bar'}, {foo: 1}, {'': 1}, {foo: {'': null}}, {array: []}, {x: [new Date()]}),

  // Circular references
  mt([] -se- it /~push/ it, {} -se [it.foo = it], [] -se- it /~push/ [it], {foo: []} -se- it.foo /~push/ it),

  // Unknowns
  mt(console, $),

  // Unknowns as unknowns
  mt(new $.serialization.unknown(10), new $.serialization.unknown($.gensym())),

  // Unknown closure under cross-stream decoding
  raise ['Unknown is not closed under cross-stream decoding (encoded: \033[1;33m#{s1(unknown) /!json}\033[0;0m vs \033[1;33m#{encoded /!json}\033[0;0m)']
  -unless [s1 /~decode/ encoded === unknown]
   -where [s1 = caterwaul.serialization(), s2 = caterwaul.serialization(), unknown = create_unknown(), encoded = s2(s2.decode(s1(unknown)))],

  // Unknown closure under mismatched decoding
  raise ['Unknown is not closed under mismatched decoding (encoded: \033[1;33m#{s1(unknown) /!json}\033[0;0m vs \033[1;33m#{encoded /!json}\033[0;0m)']
  -unless [s1 /~decode/ encoded === unknown]
   -where [s1 = caterwaul.serialization(), s2 = caterwaul.serialization(), s3 = caterwaul.serialization(), unknown = create_unknown(), encoded = s3.decode(s2(s1(unknown)))],

  where [mt() = arguments *!t -seq, json(x) = JSON.stringify(x) -rescue- '<JSON error>',
         create_unknown() = typeof document !== 'undefined' ? document.createElement('div') : new Buffer(10)]}, {t: t})(caterwaul);

// Generated by SDoc 



});
</script>

<style >
body > div {font-family: monospace}
</style>
</head>
<body >

</body>
</html>

# Generated by SDoc 
