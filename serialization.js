// Caterwaul serialization support | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This project is a reimplementation of Rather Insane Serialization (github.com/spencertipping/rather-insane-serialization) for Caterwaul. In addition to the functionality implemented in Rather
// Insane Serialization, this project also provides support for opaque references, which are associated with a specific serialization stream. This is useful for dealing with non-serializable
// values that are intermixed with normal ones. The most common use case for this is probably sending DOM nodes or jQuery collections to a server and then resolving them back into local objects
// when they reach the client again. This serialization library encodes the object's opaque identity whenever a reference is used; that way you have the property that for any reference X,
// deserialize(serialize(X)) === X. (This is true even if X changes state between serialization and deserialization.)

caterwaul('js_all')(function ($) {

// Serialization format.
// Serialized values are stored as printable ASCII strings, just like in Rather Insane Serialization. However, the format is not backwards-compatible in the general case. The following Javascript
// values are encoded as predefined constants, as before:

// | 0. undefined
//   1. null
//   2. value-type false
//   3. value-type true
//   4. value-type NaN
//   5. value-type -Infinity
//   6. value-type +Infinity
//   7. value-type 0

// Unlike the previous format, however, every value has a two-character prefix that indicates both its type and its serialized length. This prefix provides enough information to delegate to a
// separate decoder for that type of value. The following types are encoded:

// | 0. Primitive number
//   1. Primitive string
//   2. Unknown (used for opaque value encoding)
//   3. Reference boolean
//   4. Reference number
//   5. Reference string
//   6. Array
//   7. Object
//   8. Date
//   9. Regexp
//  10. Function (no closure support, unfortunately; but local referencing is used)

// This library leaves the remaining 83 spaces open for future use. Lengths are encoded as variable-length 53-bit integers (more on this below). Then the data representing the object follows for
// the next <length> bytes. (It's safe to assume bytes in a UTF-8 world because all encoded characters fall within the range 33-126, inclusive.)

  $.serialization = capture [

// Numeric encoding.
// There are two ways to encode numbers. One is used for integers, and the other is used for floating-point numbers. The format is similar to the one used in Rather Insane Serialization. Integers
// use a variable-length encoding that can handle up to 53 bits (8.08 bytes of entropy using base-94 encoding). Small numbers are preferred to large ones; that is, they take up less space. The
// format uses the first character to determine the length and supply some entropy. Specifically:

// | 1. The first character is 33 - 109: interpret literally as a single-character unsigned integer between 0 and 76, inclusive.
//   2. The first character is 110 - 117: encodes a length between 2 and 9, inclusive; the following characters are unsigned positive base-94 integer digits.
//   3. The first character is 118 - 125: encodes a length between 2 and 9, inclusive; the following characters are unsigned negative base-94 integer digits.

// Integers are little-endian encoded. This means that the least-significant base-94 digit comes first, not last. So the bytes [34, 33] means the number 1, not 94.

    radix_encode(n) = n /~![base <= n][String.fromCharCode(33 + (n / (base *= 94) >>> 0) % 94)] -seq -re- it.slice(1).join('') -where [base = 1 / 94],
    radix_decode(n) = n.split('') /[0][x0 + (x.charCodeAt(0) - 33) * (base *= 94)] -seq -where [base = 1 / 94]]})(caterwaul);

// Generated by SDoc 
